Wie werden Interfaces aus dem UML-Komponenten-Diagramm in Code umgesetzt?
1) Eine Komponente hat Eingaenge (UML-Interface)
	Sie sind modelliert durch verschiedene Java-Interfaces, die von EINEM Komponenten-Object implementiert werden.
	Dieses ist aber ein static Member der Komponenteklasse.
	Es gibt fuer jedes Interface einen getter auf das Object, das als das jeweilige Interface deklariert ist.
2) Eine Komponente hat Ausgaenge (UML-Socket)
	Sie sind modelliert durch sogenannte "Adapter"-Klasse, die reine Utility-Klassen sind (nur statische Methoden, keinen Objekte)
	Je Ausgang gibt es eine Adapter-Klasse die alle benötigten Methoden der Zielkomponente implementiert
	In den gewöhnlichen, internen Klassen der Komponente können diese Adapterklassen mit static import verwendet werden.

Alle Ein- und Ausgaenge sind im package *.dependency angelegt

Dadurch ergibt sich folgende Coderichtlinie:
	Interne Klassen einer Komponten dürfen keine imports auf Klassen außerhalb der Komponente haben
	Ausgenommen davon sind nur die Adapter-Klassen
	
	
Warum modellieren wir das so?
	Dadurch sieht man an einer einzigen Stelle, welche Komponente welche Funktionalitäten von anderen Komponenten verwendet
	Der Programmier sieht schnell ob er eine Komponentegrenze versehentlich überschreitet
	Die Adapterklassen sind extra Namespaces für static Methoden damit in der Komponentenklasse nicht zufällig eine Instanz-
		und eine static Methode gleich heißen (Java erlaubt das nicht)
	Problem: Wenn etwas public ist, könnte es von überall aus dem Projekt verwendet werden. Daran kann man nachfolgende Entwickler
	nicht hindern, egal wie die Architektur beschaffen ist.
	Unsere Architektur ermöglicht es aber über die imports schnell fest zu stellen ob gegen die Komponentengrenzen verstoßen wurde.